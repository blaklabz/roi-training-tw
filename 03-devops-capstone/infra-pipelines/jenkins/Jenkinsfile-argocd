pipeline {
    agent any

    environment {
        AWS_REGION = 'us-east-2'
        CLUSTER_NAME = 'cluster2-tw'
        KUBECONFIG_PATH = "${WORKSPACE}/kubeconfig"
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Configure AWS and Connect to EKS') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']]) {
                    sh '''
                        aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME} --kubeconfig ${KUBECONFIG_PATH}
                        export KUBECONFIG=${KUBECONFIG_PATH}
                        aws eks get-token --region ${AWS_REGION} --cluster-name ${CLUSTER_NAME} | jq -r '.status.token' > token.txt
                        export TOKEN=$(cat token.txt)
                        kubectl --kubeconfig=${KUBECONFIG_PATH} config set-credentials arn:aws:eks:${AWS_REGION}:906328874067:cluster/${CLUSTER_NAME} --token=$TOKEN
                    '''
                }
            }
        }

        stage('Install ArgoCD') {
            steps {
                sh '''
                    export KUBECONFIG=${KUBECONFIG_PATH}
                    kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
                    kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
                '''
            }
        }

        stage('Expose ArgoCD via LoadBalancer') {
            steps {
                sh '''
                    export KUBECONFIG=${KUBECONFIG_PATH}
                    kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'
                '''
            }
        }

        stage('Wait for ArgoCD Server') {
            steps {
                script {
                    timeout(time: 2, unit: 'MINUTES') {
                        waitUntil {
                            def status = sh(script: "kubectl --kubeconfig=${KUBECONFIG_PATH} get svc -n argocd argocd-server -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'", returnStdout: true).trim()
                            return status != ""
                        }
                    }
                }
            }
        }

        stage('Deploy ArgoCD Application') {
            steps {
                sh '''
                    export KUBECONFIG=${KUBECONFIG_PATH}
                    cat <<EOF | kubectl apply -f -
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: bluegreen-demo
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/blaklabz/roi-training-tw.git
    targetRevision: HEAD
    path: 03-devops-capstone/apps/your-app
    helm:
      valueFiles:
        - values.yaml
  destination:
    server: https://kubernetes.default.svc
    namespace: default
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
EOF
                '''
            }
        }

        stage('Print ArgoCD UI Info') {
            steps {
                sh '''
                    export KUBECONFIG=${KUBECONFIG_PATH}
                    echo "ArgoCD UI will be available at:"
                    kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' && echo
                    echo "To get admin password run:"
                    echo "kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath='{.data.password}' | base64 -d && echo"
                '''
            }
        }
    }
}
